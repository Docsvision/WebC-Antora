= Сохранение изменений карточки

Следующий код сохраняет все изменения карточки:

[source,tsx]
----
export async function saveCard(sender: CustomButton, e: IEventArgs) {
    await MessageBox.ShowConfirmation("Сохранить карточку?");

    // Получаем разметку карточки (cardLayout) и вызываем её метод saveCard для сохранения
    layoutManager.cardLayout.saveCard();
}

----

Чтобы сохранить изменения определенного элемента управления, используйте его метод save:

[source,tsx]
----
export function saveDescription(sender: CustomButton, e: IEventArgs) {
    // Получаем элемент управления Description, данные которого сохраняются
    let cardDescription = sender.layout.controls.get<TextArea>("Description");

    // Вызываем метод save для сохранения изменений
    cardDescription.save();
}

----

Обратите внимание, что сохранение карточки может привести к ошибке «Содержимое карточки было изменено другим пользователем. Пожалуйста, обновите карточку и выполните операцию снова», если за сохранением следует другая операция, изменяющая карточку. Например, данная ошибка возникнет при сохранении карточки, если сохранение вызывается в обработчике изменения состояния карточки.

Чтобы обойти данную ошибку, приостановите обработку основного события до сохранения карточки, а сохранение сделайте асинхронным. Следующий код демонстрируется данный способ:

[source,tsx]
----
export async function onChangeState(sender: Layout, e: CancelableEventArgs<ICardStateChangingEventArgs>) {
        let description = sender.controls.get<TextArea>("Description");
    
        description.value = description.value + "\nЗарегистрировано"; // Изменяем значение поля карточки
    
        e.wait(); // Приостанавливаем обработку основного события
        await sender.saveCard(); // Асинхронное сохранение
        e.accept(); // Продолжаем обработку
}
----