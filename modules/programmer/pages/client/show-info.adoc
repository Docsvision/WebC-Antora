= Отображение сообщений, запросов, предупреждений

Сервисы представляют основной API взаимодействия с системой в части функциональности, не связанной с конкретными элементами управления. Они позволяют получить информацию о текущем контексте выполнения, выполнять запросы к серверу, показывать модальные окна, взаимодействовать с разметкой и использовать множество других функций системы.

// При вызове обработчика `confirmationHandler` будет отображено диалоговое окно подтверждения действия:
//
// .Диалоговое окно подтверждения
// image::message-box.png[Диалоговое окно подтверждения]

[#message]
== Сервис отображения окна сообщений

Показать на экране простое информационное сообщение можно с помощью сервиса `$MessageWindow`.

Основные методы этого сервиса: `showInfo`, `showWarning`, `showError`. Они различаются только цветом оформления и отображают диалог следующего вида:

.Диалоговое окно подтверждения
image::message-box.png[Диалоговое окно подтверждения]

В качестве параметра для этих методов можно передать как простую строку, так и React-разметку для отображения произвольного содержимого.

[source,typescript]
----
export async function onButtonClick(sender: LayoutControl, args: IEventArgs) {
     const messageWindow = sender.getService($MessageWindow);
     await messageWindow.showConfirmation("Вы действительно хотите удалить файл?");
     deleteFile();
}
----

[#query]
== Сервисы для выполнения запросов

Выполнение запросов к серверу осуществляется через сервис `$RequestManager`. Сформировать URL запроса поможет сервис `$UrlResolver`. Например:

[source,typescript]
----
export async function onCustomButtonClick(sender: CustomButton) {
    const requestManager = sender.getService($RequestManager);
    const urlResolver = sender.getService($UrlResolver);
    const url = urlResolver.resolveApiUrl("MyAction", "MyController");
    const response = await requestManager.post(url, JSON.stringify({ data: 42 }));
}
----

Выполнение запросов через `$RequestManager` дает следующие преимущества, перед выполнением запросов через нативное браузерное API (`fetch`, `xhr`):

* Во время выполнения запроса на экране вверху будет отображаться стандартный индикатор прогресса.
* Ошибки, возникшие на сервере при выполнения запроса (необработанные исключения) будут отображены автоматически в соответствующем диалоге. Также могут быть корректно обработаны некоторые стандартные системные ошибки (например, если пользователь не авторизован).
* Если запрос меняет данные карточки и возвращает корректно заполненный объект CommonResponse, то сервис автоматически обновит timestamp в сервисе $CardTimestamp. В результате при следующем запросе на редактирование карточки не появится ошибка "Карточка была изменена".

Стоит обратить внимание, что последний необязательный параметр в методах `get` и `post - options` типа `RequestOptions`. Он позволяет настроить поведение `$RequestManager`, например:

* `isShowLoadingBar` -- отключает прогресс бар, `isShowOverlay` - включает затемнение на весь экран (блокирует взаимодействие пользователя с системой до окончания выполнения запроса).
* `disableDialogsOnErrors` -- отключает отображение диалогов с ошибками.
* `returnRawResponse` -- отключает обработку ответа, ответ возвращается "как есть".
* `disableRouteChangeProtection` -- флаг, который должен быть взведен при отправке запросов из обработчиков роута.
* `contentType/responseType/customHeaders` - дополнительные параметры запроса
* `rejectValue` - позволяет настроить текст ошибки, передаваемый в функцию reject промиса при ошибке во время выполнения запроса
* `noCache` - позволяет включить кеширование запроса (по умолчанию выключено).

Передать опции можно, например так:

[source,typescript]
----
try {
    await requestManager.post(url, JSON.stringify({ data: 42 }), { disableDialogsOnErrors: true });
} catch (err) {
    <.>
}
----
<.> Обработаем ошибку самостоятельно.

Запросы к стандартным контроллерам {wc}а осуществляются через специальные сервисы, которые имеют название аналогичное имени контроллера. Например, `$CardDataController` предоставляет доступ к стандартному контроллеру `CardDataController`. Все стандартные контроллеры объединены в типе `$StandardControllers`.
