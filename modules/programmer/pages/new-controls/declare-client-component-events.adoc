= Объявление событий элемента управления в клиентском компоненте

.Чтобы корректно объявить обрабатываемое событие в клиентском компоненте элемента управления, нужно выполнить два условия:
- [x] Генерируемые элементом управления события должны быть проинициализированы.
- [x] Событие должно быть сгенерировано.

== Инициализация событий

Для примера рассмотрим инициализацию события `*onShowed*`, поддерживаемого элементом управления:

[source,typescript]
----
export class SuperControlParams extends BaseControlParams { <.>
    @apiEvent onShowed?: BasicApiEvent<IEventArgs>;
}
----
<.> Класс параметров с объявлением события `onShowed`.

Для инициализации события `onShowed`, нужно добавить в конструктор класса реализации следующий код:

[source,typescript]
----
this.state.onShowed = SimpleEvent.Create<IEventArgs>(this.state.wrapper);
----

Событие `onShowed` является непрерываемым (имеет тип `BasicApiEvent`). Для прерываемого события, инициализация будет выглядеть следующим образом:

[source,typescript]
----
this.state.onShowing = CancelableEvent.Create<IEventArgs>(this.state.wrapper);
----

Таким образом конструктор класса реализации может выглядеть так:

[source,typescript]
----
construct() {
    super.construct();

    this.state.onShowed = SimpleEvent.Create<IEventArgs>(this.state.wrapper);
    this.state.onShowing = CancelableEvent.Create<IEventArgs>(this.state.wrapper);
}
----

== Генерация события

[source,typescript]
----
SimpleEvent.cast(this.state.onShowed).trigger({} as IEventArgs);

await CancelableEvent.cast(this.state.onShowing).trigger({} as IEventArgs).promise;
----

== Связать обработчики с контекстом

Связывание обработчика с контекстом выполняется в конструктор класса реализации, что демонстрируется в следующем коде, в котором выполняется связывание с контекстом обработчика события `onClick`.

[source,typescript]
----
construct() {
    super.construct();

    this.clickHandler = this.clickHandler.bind(this); <.>
}
----
<.> Метод `clickHandler` является внутренним обработчиком события `onClick`.
