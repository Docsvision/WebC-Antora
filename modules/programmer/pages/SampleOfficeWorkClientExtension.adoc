= Создание клиентского расширения с реализацией элемента управления

Непосредственно элемент управления для {wc}а реализуется в клиентском расширении, и состоит из нескольких частей (см. пункт link:CreateClientComponent.md[Разработка и публикация клиентского компонента элемента управления]): класс параметров, интерфейс состояния, интерфейсный класс и класс реализации.

С точки зрения пользовательского интерфейса реализуемый элемент управления будет представлять собой поле для ввода текста, в котором по умолчанию будет отображаться значение из поля карточки, связанного со строкой Дела Справочника номенклатуры дел 5. Особенностью элемента управления является необходимость реализации дополнительного графического компонента, в котором будут отображаться данные для выбора значения из Справочника номенклатуры дел 5, а также возможность быстрого поиска дел по справочнику.

== Клиентский сервис для работы со Справочником номенклатуры дел 5

Реализуемому элементу управления потребуется доступ к Справочнику номенклатуры дел 5, который предоставляют веб-методы, разработанные в link:SampleOfficeWorkServerExtension.md[серверном расширении]. Взаимодействовать с веб-методами можно вызывая их напрямую в основном коде элемента или используя отдельный клиентский сервис.

Ниже представлен код такого сервиса, который будет использоваться далее.

[source,typescript]
----
// Файл RefCasesWebExtension\src\Services\RefCasesServices.ts

import { $RequestManager } from "@{dv}/webclient/System/$RequestManager";
import { urlStore } from "@{dv}/webclient/System/UrlStore";
import { Models } from "../Controls/RefCases/Data/CaseModel";
import { serviceName } from "@{dv}/webclient/System/ServiceUtils";

export class RefCasesService  {
    constructor(private services: $RequestManager) {
    }

    // Возвращает модель списка лет
    getYears(rootSectionID?: string): Promise<Models.RefCasesYearModel[]> {
        let url = urlStore.urlResolver.resolveApiUrl("GetYears", "RefCasesOperation");
        url = url + "?rootSectionID=" + rootSectionID;
        
        return this.services.requestManager.post<Models.RefCasesYearModel[]>(url, "");
    }

    // Возвращает модель списка (а точнее дерева) разделов
    getSections(yearID?: string, rootSectionID?: string): Promise<Models.RefCasesSectionModel[]> {
        let url = urlStore.urlResolver.resolveApiUrl("GetSections", "RefCasesOperation");
        url = url + "?yearID=" + yearID + "&rootSectionID=" + rootSectionID;
        
        return this.services.requestManager.post<Models.RefCasesSectionModel[]>(url, "");
    }

    // Возвращает модель списка дел
    getCases(sectionID?: string): Promise<Models.RefCasesCaseModel[]> {
        let url = urlStore.urlResolver.resolveApiUrl("GetCases", "RefCasesOperation");
        url = url + "?sectionID=" + sectionID;
        
        return this.services.requestManager.post<Models.RefCasesCaseModel[]>(url, "");
    }

    // Возвращает отображаемое название дела
    getCaseTitleName(caseID?: string): Promise<string> {
        let url = urlStore.urlResolver.resolveApiUrl("GetCaseDisplayName", "RefCasesOperation");
        url = url + "?caseID=" + caseID;
        
        return this.services.requestManager.post<string>(url, "");
    }

    // Возвращает результат поиска дела по названию
    // В skipCount и maxCount будут передаваться ограничения для количества результатов, возвращаемых сервером
    searchCase(caseName: string, skipCount: number, maxCount: number, rootSectionID?: string): Promise<Models.CaseSearchResult> {
        let url = urlStore.urlResolver.resolveApiUrl("SearchCase", "RefCasesOperation");
        url = url + "?caseName=" + caseName + "&skipCount=" + skipCount + "&maxCount=" + maxCount + "&rootSectionID=" + rootSectionID;

        return this.services.requestManager.post<Models.CaseSearchResult>(url, "");
    }
}

export type $RefCasesService = { refCasesService: RefCasesService };
export const $RefCasesService = serviceName((s: $RefCasesService) => s.refCasesService);

----

== Класс параметров

В классе параметров объявляются свойства и события элемента управления, указанные в его описателе.

Данный элемент управления представляет собой поле для ввода текста, основанный на элементе InputBasedControl, в котором уже объявлены стандартные свойства подобного элемента. Единственным новым свойством является свойство «RootSection», содержащее идентификатор корневого раздела справочника.

Ниже приведён код класса параметров, наследующий основной набор свойств от InputBasedControlParams -- класса параметров элемента InputBasedControl. Значение элемента управления описывается моделью `Models.RefCasesCaseDisplayModel`.

[source,typescript]
----
// Файл RefCasesWebExtension\src\Controls\RefCases\RefCases.tsx

export class RefCasesParams extends InputBasedControlParams<Models.RefCasesCaseDisplayModel> {

    /** Стандартный CSS класс со стилями элемента управления
        Необходимо переопределить с собственным названием CSS класса
    */
    @r standardCssClass?: string = "ref-cases";

    /** Секция справочника, из которой разрешено выбирать дела.
        Настраивается в программе _{kvr}_. Может быть пустым (ограничение отсутствует) */
    @rw rootSection?: string;

    /** Клиентские сервисы
     $RefCasesService - собственный сервис для работы с данными Справочника номенклатуры дел 5 */
    @rw services?: $LayoutDirectoryDesignerController & $EditOperationStore & $LayoutInfo & $RefCasesService;
}

----

== Интерфейс состояния

В интерфейсе состояния нужно объявить свойства, описывающие внутреннее состояние элемента управления. В частности во внутреннем состоянии будет храниться «биндинг» элемента управления.

[source,typescript]
----
// Файл RefCasesWebExtension\src\Controls\RefCases\RefCasesImpl.tsx

/** @internal */
export interface RefCasesState extends RefCasesParams, InputBasedControlState<Models.RefCasesCaseDisplayModel> {
    // Используется для хранения биндинга
    binding: IBindingResult<Models.RefCasesCaseDisplayModel>;
    
    // Диалоговое окно выбора Дела из справочника
    dialog: ModalWindow;

    // Вспомогательный компонент, предоставляющий метод для обработки длительных операций (будет использоваться при получении данных из справочника)
    requestHelper: RequestHelper;
    
    // Событие ввода значения в поле элемента управления
    inputKeyDown: SimpleEvent<React.KeyboardEvent<any>>;
}

----

== Интерфейсный класс

В интерфейсном классе необходимо создать экземпляр реализации элемента управления, загрузить «биндинг», а также реализовать метод getBindings, возвращающий «биндинг» с текущим значением.

[source,typescript]
----
// Файл RefCasesWebExtension\src\Controls\RefCases\RefCases.tsx

export class RefCases extends InputBasedControl<Models.RefCasesCaseDisplayModel, RefCasesParams, RefCasesState>
{
    protected getServices(): $LayoutInfo {
        return this.state.services;
    }
    
    // Инициализация параметров элемента управления
    protected createParams(): RefCasesParams {
        return new RefCasesParams();
    }
    
    // Загружаем биндинг при инициализации элемента управления
    @handler("binding")
    protected set binding(binding: IBindingResult<Models.RefCasesCaseDisplayModel>) {
        this.value = binding && binding.value;
        this.state.canEdit = editOperationAvailable(this.state.services, binding);
        this.state.binding = binding;
    }

    // Возвращаем биндинги
    protected getBindings() {
        let binding = cloneObject(this.state.binding);
        return [getBindingResult(binding, this.params.value && this.params.value.id || null, () => at(RefCasesParams).labelText)];
    }

    // Предоставляем экземпляр реализации элемента управления Справочник номенклатуры дел 5
    protected createImpl() {
        return new RefCasesImpl(this.props, this.state);
    }
}

----

== Класс реализации

В данном примере элемент управления представляет собой поле для ввода текста, дополненное функцией быстрого поиска, реализуемой с использованием компонента Typeahead.

Реализация класса в данном примере является достаточно большой: здесь код будет приведён частично.

[source,typescript]
----
// Файл RefCasesWebExtension\src\Controls\RefCases\RefCasesImpl.tsx

/** @internal */
export class RefCasesImpl extends InputBasedControlImpl<Models.RefCasesCaseDisplayModel, RefCasesParams, RefCasesState>
{
    constructor(props: RefCasesParams, state: RefCasesState) {
        super(props, state);

        // Инициализация компонента для выполнения длительных операций
        this.state.requestHelper = new RequestHelper(() => this.forceUpdate());
        
        this.state.inputKeyDown = new SimpleEvent<React.KeyboardEvent<any>>(this);

        // Связывание обработчиков с контекстом
        this.findItems = this.findItems.bind(this);
        this.showDictionary = this.showDictionary.bind(this);
        this.onSelected = this.onSelected.bind(this);
        this.attachTypeahead = this.attachTypeahead.bind(this);
    }

    
    // Отрисовка основного элемента управления: поле для ввода текста, к которому добавляется стандартная кнопка выбора значения из справочника
    protected renderInputWithPlaceholder(): React.ReactNode {

        // Кнопка открытия справочника. Отключается, если нет прав на операцию редактирования
        let buttons: IBoxWithButtonsButtonInfo[] = [
            {
                onClick: this.showDictionary,
                name: "open-dictionary",
                iconClassName: "open-dictionary-button-icon dv-ico dv-ico-dictionary",
                visible: this.editAvailable,
                title: resources.RefCases_SelectFromDirectory,
                disabled: !this.editAvailable,
                tabIndex: this.getTabIndex(),
            }
        ];

        // Формируем элемент с быстрым поиском
        return (
            <Typeahead className={"universal-directory-box"} extraButtons={buttons}
                findItems={this.findItems} 
                clearButton={this.hasValue()} 
                searchText={this.state.inputText}
                afterOpenCallback={() => this.afterOpenCallback()}
                popoverClassName={this.state.standardCssClass} 
                popoverAttributes={{ "data-control-name": this.state.name }}
                inputKeyDown={this.state.inputKeyDown} 
                onSelected={this.onSelected}
                disabled={!this.editAvailable} 
                ref={this.attachTypeahead}>
                {super.renderInputWithPlaceholder()}
            </Typeahead>
        );
    }
    
    // Метод, отображающий диалоговое окно выбора дела из справочника (реализовано в отдельном компоненте)
    async showDictionary() {
        if (this.state.dialog && this.state.dialog.IsOpened) {
            return;
        }

        // Компонент диалогового окна выбора из справочника
        let controlInModal: RefCasesSelectDialog;

        // Устанавливаем параметры диалогового окна
        let params = new ModalWindowParams();
        params.headerText = resources.RefCases_SelectFromDirectory;
        params.content = "";
        params.buttonOkShow = true;
        params.buttonOkText = resources.Navigator_ButtonSelect;

        // Обработчик нажатия кнопки ОК в диалоговом окне
        let okFunction = () => {
            let selectedCase = cloneObject(controlInModal.selectedCase);

            // Если выбрано Дело, его модель (RefCasesCaseDisplayModel) устанавливается в значение элемента управления
            if (selectedCase) {
                this.state.services.refCasesService.getCaseTitleName(selectedCase.uniqueId).then((title) => {

                    let displayValue = {
                        id: selectedCase.uniqueId,
                        name: title
                    } as Models.RefCasesCaseDisplayModel;

                    this.setValue(displayValue, true);
                });

                if (this.state.dialog) {
                    this.state.dialog.Hide();
                    this.state.dialog = null;
                }
            }
        };

        // Устанавливается обработчик нажатия кнопки ОК
        params.buttonOkFunction = okFunction;

        // Получаем текущее значение элемента управления
        const value = this.getValue();
        this.state.dialog = new ModalWindow(params);

        // Формируем диалоговое окно
        renderModalContent(this.state.dialog, (
            <RefCasesSelectDialog key={this.state.name + "_Modal"} ref={(el) => controlInModal = el}
                rootSectionId={this.state.rootSection}
                services={this.state.services}

                // Кнопка ОК включается при выборе Дела  
                nodeSelected={(node) => {
                    if (this.state.dialog) {
                        if (node) this.state.dialog.OkButtonElement.classList.remove("disabled");
                        else this.state.dialog.OkButtonElement.classList.add("disabled");
                    }
                }}

                // Обработчик для двойного щелчка по делу - аналогично нажатию кнопки ОК
                nodeAccepted={okFunction} />
        ));

        this.state.dialog.Show();
        this.state.dialog.OkButtonElement.classList.add("disabled");
    }
    
    // Обработчик события быстрого поиска по справочнику
    // Результаты поиска отображаются в списке, выводимом под окном поля ввода
    protected findItems(typeaheadQuery: ITypeaheadSearchQuery): Promise<ITypeaheadSearchResult> {
        return new Promise<ITypeaheadSearchResult>((resolve, reject) => {
            this.state.services.refCasesService.searchCase(typeaheadQuery.searchText, typeaheadQuery.skipCount, typeaheadQuery.maxCount, this.state.rootSection).then(response => {               
                let result = {
                    // Результаты поиска, д.б. приведены к ITypeaheadSearchResult
                    items: response.items.map(item => new CaseTypeaheadVariant(item)),

                    // Флаг, сообщающий о наличии результатов, не включенных в данный ответ
                    hasMore: response.hasMore
                } as ITypeaheadSearchResult;
                resolve(result);
            }).catch(reject);
        });
    }
}

----

В данном компоненте три ключевых функции: 

* renderInputWithPlaceholder -- формирует поле для ввода текста с возможностью быстрого поиска, которая реализована в компоненте Typeahead;
* showDictionary -- открывает диалоговое окно с элементами для выбора дела из справочника;
* findItems -- реализует функцию получения результатов поиска дел по справочнику.

Компонент Typeahead умеет ограничивать кол-во результатов, получаемых за один раз. Данные ограничения регулируются с помощью его параметров: 

* firstPageSize -- максимальное кол-во результатов при первом запросе, по умолчанию -- 8;
* nextPageSize -- максимальное кол-во результатов при следующих запросах, по умолчанию -- 15.

При выполнении первого запроса в функцию findItems передаётся аргумент ITypeaheadSearchQuery со значениями skipCount = 0 и maxCount = firstPageSize. При следующем запросе -- при нажатии пользователем кнопки «Показать еще», в findItems передаются значения skipCount = firstPageSize и maxCount = nextPageSize. Таким образом клиент может запросить у сервера недостающие данные, если после первого запроса сервер вернул флаг hasMore = true.

== Компонент диалогового окна выбора дела из справочника

Диалоговое окно выбора дела из Справочника номенклатуры дел представляет собой панель с тремя элементами управления: раскрывающийся список для выбора года, дерево разделов и дерево дел

____

В модуле «Делопроизводство 5» секция дел является древовидной, функция вложенных дел не используется. Тем не менее в данном примере для совместимости используется элемент, поддерживающий древовидную структуру данных.

____

С целью уменьшения количества исходного кода в данном примере умышленно не используется функция выбора текущего значения элемента управления в окне выбора Дела. Данная возможность может быть реализована самостоятельно.

В приведённом далее коде пропущены участки с классом параметров и интерфейсом состояния диалогового окна. Полный исходный код доступен на GitHub.

[source,typescript]
----
// Файл RefCasesWebExtension\src\Controls\RefCases\RefCasesSelectDialog\RefCasesSelectDialog.tsx

export class RefCasesSelectDialog extends React.Component<IRefCasesSelectDialogProps, IRefCasesSelectDialogState> {

    /** @internal */
    state: IRefCasesSelectDialogState;

    constructor(props: IRefCasesSelectDialogProps) {
        super(props);

        this.state = {} as IRefCasesSelectDialogState;
        this.state.requestHelper = new RequestHelper(() => this.forceUpdate());

        
        // Связывание функций и обработчиков событий с контекстом
        this.collectYearsList = this.collectYearsList.bind(this);
        this.loadSectionsTree = this.loadSectionsTree.bind(this);
        this.loadCasesTree = this.loadCasesTree.bind(this);

        this.onSectionNodeSelected = this.onSectionNodeSelected.bind(this);
        this.onCaseNodeSelected = this.onCaseNodeSelected.bind(this);
        this.onCaseNodeAccepted = this.onCaseNodeAccepted.bind(this);

        // Загружаем список лет из справочника
        this.collectYearsList();
    }

    // Загружает из Справочника номенклатуры дел 5 список лет в state.years, который является источником данных для элемента управления CommonComboBox
    protected collectYearsList() {
        // Если установлен раздел, из которого возможен выбор дел - rootSectionId, будет возвращен только год с данным разделом
        this.props.services.refCasesService.getYears(this.props.rootSectionId).then((items) => {
            this.state.years = items.map(x => ({
                id: x.id,
                title: x.displayValue
            } as IComboBoxElement));
     
            // Показываем элемент со списком лет
            this.setState({ showYearsList: true });
        });
    }

    // Возвращает  список разделов из Справочника номенклатуры дел 5
    protected loadSectionsTree(): Promise<IDynamicTreeNodeData[]> {
        return new Promise<IDynamicTreeNodeData[]>((resolve, reject) => {
            this.state.requestHelper.send(
                () => this.props.services.refCasesService.getSections(this.state.selectedYearID, this.props.rootSectionId),
                items => {
                    let nodes = RefCasesSectionTreeNode.Create(items);
                    resolve(nodes);
                },
                reject);
        });
    }

    // Возвращает  список дел из Справочника номенклатуры дел 5
    protected loadCasesTree(): Promise<IDynamicTreeNodeData[]> {
        return new Promise<IDynamicTreeNodeData[]>((resolve, reject) => {
            this.state.requestHelper.send(
                () => this.props.services.refCasesService.getCases(this.state.selectedSectionID),
                items => {
                    let nodes = RefCasesCaseTreeNode.Create(items);
                    resolve(nodes);
                },
                reject);
        });
    }

    // Загружает список дел после выбора раздела
    protected onSectionNodeSelected(node: TreeNode) {
        this.state.selectedSectionID = node.uniqueId;
        
        this.state.selectedCaseNode = null;
        this.props.nodeSelected && this.props.nodeSelected(null);
        
        this.setState({ showCasesTree: false }, () => this.setState({ showCasesTree: true }));
    }

    // Сохраняет дело в selectedNode после его выбора в списке дел
    protected onCaseNodeSelected(node: TreeNode) {
        this.state.selectedCaseNode = node.data as RefCasesCaseTreeNode;
        this.props.nodeSelected && this.props.nodeSelected(node.data as RefCasesCaseTreeNode);
    }

    // Сохраняет дело в selectedNode после его выбора в списке дел и нажатия кнопки Выбрать
    protected onCaseNodeAccepted(node: TreeNode) {
        this.state.selectedCaseNode = node.data as RefCasesCaseTreeNode;
        this.props.nodeAccepted && this.props.nodeAccepted(node.data as RefCasesCaseTreeNode);
    }

    // Инициализация интерфейса
    render(): React.ReactNode {

        // Список лет
        let yearsList = <div>{resources.RefCases_Years}
            <CommonComboBox elements={this.state.years} selectedID={this.state.selectedYearID}
            // При выборе года из списка инициализируем дерево разделов
            onChange={(selectedElement: IComboBoxElement) => {
                this.setState({ selectedYearID: selectedElement.id });
                // Элемент для выбора Раздела перемонтируется, элемент для выбора Дела отмонтируется
                this.setState({ showSectionsTree: false }, () => this.setState({ showSectionsTree: true }));
                this.setState({ showCasesTree: false });
                this.forceUpdate();
            }}

            renderElementList={(elements, expanded) =>
                <PopoverComboBoxBodyContent mode={PopoverMode.BottomDropdown} isOpen={expanded} className="combobox-helper">
                    {elements}
                </PopoverComboBoxBodyContent>
            } />
            </div>;

        // Дерево разделов
        let sectionsTree = <div className={"ref-cases-dialog__tree"}>
            <div className="tree-block">{resources.RefCases_Sections}
                <DynamicTree loadNodes={this.loadSectionsTree} treeHeight={300} 
                // При выборе Раздела из дерева разделов вызываем метод, загружающий дерево Дел
                nodeSelected={this.onSectionNodeSelected} >
                </DynamicTree>
            </div>
        </div>;

        // Список дел
        let casesTree = <div className={"ref-cases-dialog__tree"}>
            <div className="tree-block">{resources.RefCases_Cases}
                <DynamicTree loadNodes={this.loadCasesTree} treeHeight={300} 
                // При выборе Дела, сохраняем значение узла, а при двойном щелчке вызываем обрабочик onCaseNodeAccepted
                nodeSelected={this.onCaseNodeSelected} nodeAccepted={this.onCaseNodeAccepted} >
                </DynamicTree>
            </div>
        </div>;

        return (
            <div>
                {this.state.showYearsList && yearsList}
                {this.state.showSectionsTree && sectionsTree}
                {this.state.showCasesTree && casesTree}
            </div>
        );
    }
}
----

Пример стиля для дерева дел и дерева разделов:

[source,scss]
----
// Файл RefCasesWebExtension/src/Controls/RefCases/RefCasesSelectDialog/RefCasesSelectDialog.scss

.ref-cases-dialog__tree {
    border-bottom: 1px solid lightgray;
    padding-top: 10px;
    display: inline-block;
    width: 50%;
}
----