= Механизм внедрения зависимостей на клиенте

В данном разделе рассмотрены особенности передачи клиентских сервисов с использованием механизма внедрения зависимостей.

// В {wc}е внедрение зависимостей связано с таким понятием, как _контейнер сервисов_, упрощенная реализация которого приведена ниже.

У сервиса имеется имя и интерфейс. Например, сервис для получения информации о текущей карточке имеет имя `$CardInfo`, и интерфейс `GenModels.CardInfoModel`. Получить сервис можно по имени при помощи метода `getService` у объекта элемента управления, разметки или глобального объекта `app`. Например, таким образом можно получить сервис `$CardInfo` в обработчике события:

[source,typescript]
----
export function onCustomButtonClick(sender: CustomButton, args: IEventArgs) {
     const cardInfo = sender.getService($CardInfo);
}
----

// // no-code-check
// [source,typescript]
// ----
// var serviceContainer = {
//    urlStore: new UrlStroe(),
//    requestManager: new ReqeustManager(),
//    router: new Router()
// }
// ----

// Данный контейнер содержит три сервиса, которые могут быть переданы в метод при его вызове:
//
// // no-code-check
// [source,typescript]
// ----
// sendToAcquaintance(serviceContainer);
// ----

Сервисы, как правило, размещаются в контейнерах -- специальных объектах. Имя сервиса -- это ключ, по которому данный сервис можно получить в сервис-контейнере. Получить сервис-контейнер можно вызвав `getService` без параметров. Так альтернативный способ получения сервиса по ключу из контейнера будет выглядеть так:

[source,typescript]
----
export function onCustomButtonClick(sender: CustomButton, args: IEventArgs) {
     const cardInfo = sender.getService()[$CardInfo] as GenModels.CardInfoModel; <.>
     const cardInfo2 = sender.getService<$CardInfo>().cardInfo; <.>
}
----
<.> Получаем либо по ключу
<.> Либо иным образом

// Полноценная реализация такого контейнера в {wc}е определена в классе `ServiceContainer`, экземпляр которого доступен из статического свойства `WebClient.App.Instance` и глобальной переменной `WebClient.app`.

Сервис-контейнер уровня приложения доступен через глобальный объект app, однако его не рекомендуется использовать в большинстве случаев.

Сервис контейнер в элементах управления также доступен через параметр `services` (он же `props` при отрисовке элемента управления как React-компонента).

Все стандартные сервисы {wc}а (приведены в JSDoc API).

// Отличительной особенностью реализации контейнера `ServiceContainer` является то, что каждое свойство в нем имеет get-функцию, в которой динамически вычисляется искомое значение. В частности, для каждого сервиса в данном контейнере создаётся объект `ServiceDescriptor`, содержащий информацию о том, как должно вычисляться его значение.
//
// Класс `ServiceContainer` предоставляет функции для создания и регистрация дескрипторов, которые в `WebClient.App.Instance` представлены в виде статически методов, пример использования которых приведён ниже.
//
// // no-code-check
// [source,typescript]
// ----
// WebClient.App.registerService("urlStore", new UrlStore()); <.>
//
// WebClient.App.addService<$UrlStore>({ urlStore: new UrlStore()}); <.>
//
// WebClient.App.registerServiceFactory("urlStore", (services) => new UrlStore()); <.>
//
// WebClient.App.addServiceFactory<$UrlStore>({ urlStore: (services) => new UrlStore()}); <.>
//
// WebClient.App.registerServiceAccessors("now", () => new Date()); <.>
//
// let serviceDescriptor = { <.>
//     name: "urlStore",
//     instance: new UrlStore()
// };
// WebClient.App.registerServiceDesciptor(serviceDescriptor);
//
// var myUrlStore = WebClient.app.with<$UrlStore>().urlStore; <.>
// ----
// <.> Регистрация с передачей имени свойства и значения.
// <.> Вариант регистрации с передачей объекта.
// <.> Регистрация фабрики сервиса с передачей имени. Фабрика будет вызвана при первом обращении к сервису, после чего значение будет кэширована.
// +
// Функция принимает объект контейнера, актуального на момент её вызова.
// <.> Вариант регистрации фабрики сервиса с передачей объекта.
// <.> Регистрация динамически вычисляемого значения.
// +
// Функция будет вызываться при каждом обращении к сервису. Можно также передать set-функцию.
// <.> Передача дескриптора сервиса созданного вручную.
// <.> Использование зарегистрированного сервиса.
//
== Создание сервисов

.Определение сервиса включает в себя три составляющих:
* Описание интерфейса сервиса и его имени.
* Определение реализации.
* Регистрация реализации.

. Первое, что нужно сделать -- выбрать название сервиса. Допустим, наш сервис будет называться `Greeting`. Тогда описание интерфейса и имени сервиса будет выглядеть следующим образом:
+
[source,typescript]
----
export interface IGreetingService {
     showGreeting(name: string): Promise<void>;
}
export type $Greeting = { greeting: IGreetingService };
export const $Greeting = serviceName<$Greeting, IGreetingService>(x => greeting);
----
+
. Реализацию сервиса рекомендуется определять в отдельном от интерфейса файле (чтобы не создавать лишние зависимости). Реализацией будет определение класса, реализующего интерфейс `IGreetingService`.
+
[source,typescript]
----
export class GreetingSevice implements IGreetingService {
      constructor(private services: $MessageWindow) {
      }
      showGreeting(name: string): Promise<void>{
            return this.services.messageWindow.showInfo("Добро пожаловать, " + name);
      }
 }
----
+
. Регистрируются сервисы в файле `Index.ts` веб-расширения через вызов `registerExtension`. Если сервис имеет отношение к разметке, то следует передавать его в поле `layoutServices`, иначе в `globalServices`.
+
[source,typescript]
----
extensionManager.registerExtension({
      name: "Greeting",
      version: "1.0",
      layoutServices: [
           Service.fromFactory($Greeting,
                (services: $StandardServices & $StandardControllers) =>
                      new GreetingSevice(services))
      ]
})
----

// Некоторые сервисы, такие как `RequestManager`, должны быть созданы для каждой разметки заново. Такие сервисы регистрируются специальным образом, с передачей дополнительных метаданных:

// // no-code-check
// [source,typescript]
// ----
// app.addServiceFactory<$RequestManager>( <.>
//     { requestManager:  (services: $Layout) => new RequestManager(services) },
//     WebClient.LAYOUT_SERVICE
// );
// ----
// <.> Сервис специфичный для разметки. Передаем дополнительным параметром метаданные -- объект `WebClient.LAYOUT_SERVICE`

// При открытии разметки, будет создана копия контейнера `WebClient.App.Instance`, в этой копии все сервисы зарегистрированные как фабрики с передачей `WebClient.LAYOUT_SERVICE` будут созданы повторно. То есть, фабричная функция будет вызвана для получения нового экземпляра, специфичного для данной разметки.
//
// Для доступа к контейнеру сервисов разметки можно либо напрямую обратиться к параметру `services` в элементе Layout, либо объявить параметр `services` в своем элементе управления (см. пункт xref:new-controls/get-client-component-service.adoc[Получение сервисов в клиентском компоненте]).
//
// [source,typescript]
// ----
// export class AcquaintancePanelParams extends PanelParams {
//     @rw sendButtonText: string;
//     @r standardCssClass?: string = "acquaintance-panel";
//     @r canSend?: boolean;
//
//     @apiEvent opening?: CancelableApiEvent<IEventArgs>;
//     @apiEvent opened: BasicApiEvent<IEventArgs>;
//     @apiEvent closing: CancelableApiEvent<IEventArgs>;
//     @apiEvent closed: BasicApiEvent<IEventArgs>;
//
//     @rw services?: $EditOperationStore & $LayoutBusinessProcessController & $Layout; <.>
// }
// ----
// <.> Объявляем, что для ЭУ необходимы сервисы UrlStore и RequestManager
//
// После этого, можно обращаться к этим сервисам через `this.state.services`:
//
// [source,typescript]
// ----
// sendToAcquaintance() {
//     var url = this.state.services.urlStore.urlResolver.resolveUrl("SendToAcquaintance", "LayoutBusinessProcess");
//     var data = { ...  };
//     return this.state.services.requestManager.post(url, JSON.stringify(data));
// }
// ----
//
// Т.к. `services` является обычным параметром, его можно передать элементу управления и при этом, если требуется, переопределить сервисы, с которыми работает элемент управления:
//
// [source,typescript]
// ----
// let layout = layoutManager.cardLayout;
// let myServices = layout.params.services.clone();
// myServices.requestManager = new MyRequestManager();
// layout.controls.acquaintancePanel1.params.services = myServices;
// ----
//
// WARNING: Не следует модифицировать существующий контейнер для подмены сервисов, т.к. это приведёт к изменению сервисов на уровне всего приложения.
