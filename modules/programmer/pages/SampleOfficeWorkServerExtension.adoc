= Создание серверного расширения {wc}а

В link:SampleOfficeWorkDescriptor.md[описателе элемента управления] был объявлен конвертер для значения элемента -- «RefCasesConverter» (свойство «Binding»), который должен приводить настоящее значение (идентификатор строки Дела в _Справочнике номенклатуры дел 5_) к виду, удобному для пользователя -- в данном примере к строка вида: «Год. Название разделов. Название дела».

Также для работы клиентской части понадобятся методы, предоставляющий список лет, дерево разделов и список дел из Справочника номенклатуры дел 5, а также функцию для поиска дела по названию (если нужно реализовать функцию поиска на клиенте).

== Сервис для работы со Справочником номенклатуры дел 5

Прежде всего необходимо реализовать сервис для работы со Справочником номенклатуры дел 5, методы которого должны:

* возвращать список лет;
* возвращать год для определённой секции -- нужно, если в программе {kvr} был выбран раздел, из которого выбираются дела;
* возвращать все разделы для определённого года, а если требуется, только разделы из корневого раздела, выбранного в программе {kvr};
* возвращать все дела из определённого раздела;
* возвращать отображаемое название дела -- для конвертера значений «RefCasesConverter»;
* возвращать список дел с искомым названием, а если требуется, только дела из из корневого раздела, выбранного в программе {kvr}.

Ниже представлен интерфейс сервиса, описывающего установленные требования. Первые два условия для сервиса объединены в один метод `GetYears`.

[source,csharp]
----
// Файл RefCasesServerExtension\Services\IRefCasesService.cs

using RefCasesServerExtension.Models;
using System;
using System.Collections.Generic;

namespace RefCasesServerExtension.Services
{
    public interface IRefCasesService
    {
        List<Year> GetYears(Guid? rootSection = null);
        List<Section> GetSections(Guid yearID, Guid? rootSection = null);
        List<Case> GetCases(Guid sectionID);
        string GetCaseTitle(Guid caseID);
        List<CaseClientModel> SearchCases(string caseName, Guid? rootSection = null);
    }
}

----

И реализация сервиса `IRefCasesService`:

[source,csharp]
----
// Файл RefCasesServerExtension\Services\RefCasesService.cs

using {dv}.Platform.ObjectManager;
using {dv}.Platform.WebClient;
using {dv}.Platform.WebClient.Managers;
using RefCasesServerExtension.Models;
using System;
using System.Collections.Generic;
using System.Linq;

namespace RefCasesServerExtension.Services
{
    public class RefCasesService : IRefCasesService
    {
        
        private Guid refCasesId = new Guid("246197EA-846A-44DA-9EA3-0BCAE5500388"); // Справочник номенклатуры дел 5
        private Guid yearsSectionId = new Guid("BD44C786-6E41-450E-BD60-66919657E51B"); // Секция «Года» справочника
        private Guid sectionsSectionID = new Guid("319E425D-543C-45DB-BD51-955B58476EDB"); // Секция «Разделы» справочника
        private Guid caseSectionID = new Guid("56af8231-b918-42d4-ac15-90ec2e9a0725"); // Секция «Дела» справочника

        // Названия полей
        private const string Year = "Year";
        private const string DisplayIndex = "DisplayIndex";
        private const string Case_Name = "Case_Name";
        private const string Case_Index = "Case_Index";
        private const string Case_SectionDisplayIndex = "Case_SectionDisplayIndex";
        private const string Name = "Name";

        ICurrentObjectContextProvider objectContextProvider;
        private AdvancedCardManager cardManager => objectContextProvider.GetOrCreateCurrentSessionContext().AdvancedCardManager;

        public RefCasesService(ICurrentObjectContextProvider objectContextProvider) => this.objectContextProvider = objectContextProvider;

        // Возвращает список лет из Справочника номенклатуры дел 5
        public List<Year> GetYears(Guid? rootSection)
        {
            CardData refCasesData = cardManager.GetDictionaryData(refCasesId);
            SectionData yearSection = refCasesData.Sections[yearsSectionId];

            // Если выбран корневой раздел, нужно вернуть только его Год
            if (rootSection.HasValue && refCasesData.Sections[sectionsSectionID].RowExists(rootSection.Value))
            {
                var sectionRow = refCasesData.Sections[sectionsSectionID].GetRow(rootSection.Value);
                var yearRow = sectionRow.SubSection.ParentRow;

                return new List<Year>() {
                    new Year() { ID = yearRow.Id, DisplayValue = yearRow[Year].ToString() }
                };
            }

            // Иначе возвращаем все года
            return yearSection.Rows.Select<RowData, Year>(row => new Year()
            {
                ID = row.Id,
                DisplayValue = row[Year].ToString()
            }).ToList();
        }

        // Возвращает дерево разделов указанного года из Справочника номенклатуры дел 5 
        public List<Section> GetSections(Guid yearID, Guid? rootSection)
        {
            CardData refCasesData = cardManager.GetDictionaryData(refCasesId);
            SectionData sectionsSection = refCasesData.Sections[sectionsSectionID];

            // Если выбран корневой раздел, вернуть только его подразделы
            if (rootSection.HasValue && sectionsSection.RowExists(rootSection.Value))
            {
                RowData row = sectionsSection.GetRow(rootSection.Value);
                return GetSectionsFromRows(new List<RowData>() { row });
            }

            SectionData yearSection = refCasesData.Sections[yearsSectionId];

            // Иначе вернуть все разделы указанного года
            if (yearSection.RowExists(yearID))
            {
                RowDataCollection sectionRows = yearSection.GetRow(yearID).ChildSections[sectionsSectionID].Rows;
                return GetSectionsFromRows(sectionRows);
            }

            return new List<Section>();
        }

        // Вернуть все дела указанного раздела
        public List<Case> GetCases(Guid sectionID)
        {
            CardData refCasesData = cardManager.GetDictionaryData(refCasesId);
            SectionData sectionsSection = refCasesData.Sections[sectionsSectionID];

            if (sectionsSection.RowExists(sectionID))
            {
                RowDataCollection sectionRows = sectionsSection.GetRow(sectionID).ChildSections[caseSectionID].Rows;
                return GetCasesFromRows(sectionRows);
            }

            return new List<Case>();
        }

        // Вернуть отображаемое название дела
        public string GetCaseTitle(Guid caseID)
        {
            CardData refCasesData = cardManager.GetDictionaryData(refCasesId);
            SectionData section = refCasesData.Sections[caseSectionID];

            if (section.RowExists(caseID))
            {
                // Получаем для дела родительские строки раздела и года
                RowData caseRow = section.GetRow(caseID);
                var sectionRow = caseRow.SubSection.ParentRow;
                var yearRow = sectionRow.SubSection.ParentRow;

                return string.Format("{0}, {1}, {2}", yearRow[Year], sectionRow[DisplayIndex], caseRow[Case_Name]);
            }

            return "Ошибка!";
        }

        // Поиск дела по названию и по идентификатору дела
        public List<CaseClientModel> SearchCases(string caseName, Guid? rootSection = null)
        {
            CardData refCasesData = cardManager.GetDictionaryData(refCasesId);

            RowDataCollection allRows;

            // Если указан коневой раздел, поиск только в нём, иначе - во всех разделах
            if (rootSection.HasValue && refCasesData.Sections[sectionsSectionID].RowExists(rootSection.Value))
                allRows = refCasesData.Sections[caseSectionID].GetAllRows(rootSection.Value, true);
            else
                allRows = refCasesData.Sections[caseSectionID].GetAllRows();

            var results = new List<CaseClientModel>();

            foreach (var caseRow in allRows)
            {
                // Проверяем название раздела - поле Case_Name
                if (caseRow[Case_Name].ToString().IndexOf(caseName, StringComparison.InvariantCultureIgnoreCase) > -1 ||
                    (caseRow[Case_SectionDisplayIndex].ToString() + "-" + caseRow[Case_Index].ToString()).IndexOf(caseName, StringComparison.InvariantCultureIgnoreCase) > -1)
                {
                    var sectionRow = caseRow.SubSection.ParentRow;
                    var yearRow = sectionRow.SubSection.ParentRow;

                    results.Add(new CaseClientModel()
                    {
                        Id = caseRow.Id,

                        // Возвращаем сразу отображаемое название
                        Name = string.Format("{0}, {1}, {2}", yearRow[Year], sectionRow[DisplayIndex], caseRow[Case_Name])
                    });
                }
            }

            return results;
        }

  
        // Возвращает список Разделов для строк секции справочника
        List<Section> GetSectionsFromRows(IEnumerable<RowData> rows)
        {
            var nodes = new List<Section>();

            foreach (var row in rows)
            {
                var node = new Section() { ID = row.Id, DisplayValue = row[Name].ToString() };
                if (row.HasChildRows)
                    node.Sections = GetSectionsFromRows(row.ChildRows);

                nodes.Add(node);
            }
            return nodes;
        }

        // Возвращает список Дел для строк справочника
        List<Case> GetCasesFromRows(RowDataCollection rows)
        {
            var nodes = new List<Case>();

            foreach (var row in rows)
            {
                var node = new Case() { ID = row.Id, DisplayValue = row[Case_Name].ToString() };
                if (row.HasChildRows)
                    node.Cases = GetCasesFromRows(row.ChildRows);

                nodes.Add(node);
            }
            return nodes;
        }
    }
}

----

== Конвертер RefCasesConverter

Как уже было сказано ранее, конвертер нужен для формирования отображаемого значения элемента управления, показываемого при инициализации элемента -- иначе в элементе будет показан идентификатор выбранного дела.

Для разрабатываемого элемента управления название конвертера («RefCasesConverter») было объявлено в описателе элемента управления. Теперь его нужно реализовать и зарегистрировать в серверном расширении {wc}а.

В данном пример конвертер использует метод `IRefCasesService.GetCaseTitle` для получения отображаемого названия Дела.

[source,csharp]
----
// Файл RefCasesServerExtension\BindingConverters\RefCasesConverter.cs

using {dv}.WebClientLibrary.Layout.IL;
using {dv}.WebClientLibrary.ObjectModel;
using {dv}.WebClientLibrary.ObjectModel.Services.BindingConverters;
using {dv}.WebClientLibrary.ObjectModel.Services.LayoutModel;
using RefCasesServerExtension.Models;
using RefCasesServerExtension.Services;
using System;

namespace RefCasesServerExtension.BindingConverters
{
    // Класс конвертера может быть производным от BaseBindingConverter или полностью реализовывать интерфейс IBindingConverter 
    public class RefCasesConverter : BaseBindingConverter
    {
        private IRefCasesService refCasesService;

        // В базовый класс нужно передать название конвертера, указанного в описателе - RefCasesConverter
        public RefCasesConverter(IServiceProvider serviceProvider, IRefCasesService refCasesService) : base(serviceProvider, "RefCasesConverter")
        {
            // Получаем реализованный ранее сервис для работы со Справочником номенклатуры дел 5
            this.refCasesService = refCasesService;
        }

        // Основной метод, возвращающий отображаемое значение (а точнее модель) для значения элемента управления - bindingResult.Value
        public override BindingResult ConvertForDisplay(ControlContext controlContext, LayoutBinding binding, BindingResult bindingResult)
        {
            var itemId = bindingResult.Value != null ? (Guid)bindingResult.Value : Guid.Empty;
            var name = itemId == Guid.Empty ? "" : refCasesService.GetCaseTitle(itemId);

            // Клиент ожидает модель, включающую идентификатор и название Дела
            var model = new CaseClientModel() { Id = itemId, Name = name };

            return bindingResult.Clone(model);
        }
    }
}

----

== Веб-методы серверного расширения

Клиентской части элемента управления нужны данные из Справочника номенклатуры дела 5: для показа списка лет, разделов, а также дел. Предоставить доступ к данным можно с помощью веб-методов серверного расширения. Далее приведён код контроллера, предоставляющего такие веб-методы.

[source,csharp]
----
// Файл RefCasesServerExtension\Controllers\RefCasesOperationController.cs

using RefCasesServerExtension.Models;
using RefCasesServerExtension.Services;
using System;
using System.Web.Http;
using System.Linq;

namespace RefCasesServerExtension.Controllers
{
    public class RefCasesOperationController : ApiController
    {
        private readonly IRefCasesService refCasesService;

        // В конструкторе контроллера получаем ссылку на реализованный сервис для работы со Справочником номенклатуры дел 5
        public RefCasesOperationController(IRefCasesService refCasesService)
        {
            this.refCasesService = refCasesService;
        }

        // Возвращает список лет
        [HttpPost]
        public Year[] GetYears([FromUri]Guid? rootSectionID)
        {
            return refCasesService.GetYears(rootSectionID).ToArray();
        }

        // Возвращает список разделов
        [HttpPost]
        public Section[] GetSections([FromUri]Guid yearID, [FromUri]Guid? rootSectionID) {
            return refCasesService.GetSections(yearID, rootSectionID).ToArray();
        }

        // Возвращает список дел
        [HttpPost]
        public Case[] GetCases([FromUri]Guid sectionID)
        {
            return refCasesService.GetCases(sectionID).ToArray();
        }

        // Возвращает отображаемое название дела
        [HttpPost]
        public string GetCaseDisplayName([FromUri]Guid caseID)
        {
            return refCasesService.GetCaseTitle(caseID);
        }

        // Поиск дела по имени
        [HttpPost]
        public CaseSearchResult SearchCase([FromUri]string caseName, [FromUri]int skipCount, [FromUri]int maxCount, [FromUri]Guid? rootSectionID)
        {
            // Получаем все подходящие дела
            var rows = refCasesService.SearchCases(caseName, rootSectionID);

            var result = new CaseSearchResult
            {
                // Оставляем только количество запрошенных клиентом
                Items = rows.Skip(skipCount).Take(maxCount).ToArray(),

                // Устанавливаем флаг наличия дополнительных результатов
                HasMore = rows.Count > skipCount + maxCount
            };

            return result;
        }
    }
}

----

Т. к. количество результатов поискового запроса SearchCase может быть достаточно большим, клиенту предоставлена возможность ограничивать его с помощью параметров skipCount (кол-во пропускаемых результатов) и maxCount (максимальное количество результатов, принимаемых клиентом за один раз).

== Ядро серверного расширения

Реализованные сущности необходимо зарегистрировать в серверном расширении.

[source,csharp]
----
// Файл RefCasesServerExtension\RefCasesServerExtension.cs

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Resources;
using Autofac;
using {dv}.WebClient.Extensibility;
using {dv}.WebClient.Helpers;
using {dv}.WebClientLibrary.ObjectModel.Services.BindingConverters;
using RefCasesServerExtension.BindingConverters;
using RefCasesServerExtension.Services;

namespace RefCasesServerExtension
{
    public class RefCasesServerExtension : WebClientExtension
    {
        public RefCasesServerExtension(IServiceProvider serviceProvider)
            : base(serviceProvider)
        {
        }

        public override string ExtensionName
        {
            get { return Assembly.GetAssembly(typeof(RefCasesServerExtension)).GetName().Name; }
        }

        public override Version ExtensionVersion
        {
            get { return new Version(FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location).FileVersion); }
        }

        #region WebClientExtension Overrides

        // Регистрация компонентов, реализованных в расширении
        public override void InitializeContainer(ContainerBuilder containerBuilder)
        {
            // Регистрируем конвертер
            containerBuilder.RegisterOrderedType<RefCasesConverter, IBindingConverter>();
            
            // Регистрируем сервисы
            containerBuilder.RegisterType<RefCasesService>().As<IRefCasesService>().SingleInstance();
        }

        // Также для примера добавлено несколько локализованных текстовых ресурсов, которые будут использоваться в клиентском расширении
        protected override List<ResourceManager> GetLayoutExtensionResourceManagers()
        {
            return new List<ResourceManager>
            {
                { Resources.ResourceManager}
            };
        }

        #endregion
    }
}
----

Контроллеры регистрировать не требуется.